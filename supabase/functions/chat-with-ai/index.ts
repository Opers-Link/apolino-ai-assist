import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.57.4';
import { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version',
};

// Input validation schemas
const chatMessageSchema = z.object({
  role: z.enum(['user', 'assistant', 'system']),
  content: z.string()
    .min(1, 'Message cannot be empty')
    .max(10000, 'Message too long (max 10000 characters)')
});

const userContextSchema = z.object({
  userId: z.string().max(100).optional(),
  currentSystem: z.string().max(100).optional(),
  permissions: z.array(z.string().max(50)).max(20).optional(),
  lastAction: z.string().max(200).optional()
}).optional();

const requestSchema = z.object({
  messages: z.array(chatMessageSchema)
    .min(1, 'At least one message required')
    .max(50, 'Too many messages (max 50)'),
  conversationId: z.string().uuid().optional().nullable(),
  userContext: userContextSchema
});

interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

interface UserContext {
  userId?: string;
  currentSystem?: string;
  permissions?: string[];
  lastAction?: string;
}

// Rate limiting configuration
const RATE_LIMIT_REQUESTS = 200; // Max requests per window
const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour window

async function checkRateLimit(supabase: any, sessionId: string): Promise<{ allowed: boolean; remaining: number }> {
  try {
    const windowStart = new Date(Date.now() - RATE_LIMIT_WINDOW_MS).toISOString();
    
    const { data: recentRequests, error } = await supabase
      .from('ai_usage_logs')
      .select('id')
      .eq('session_id', sessionId)
      .gte('created_at', windowStart);

    if (error) {
      console.error('Rate limit check error:', error);
      // Allow request if rate limit check fails (fail open for usability)
      return { allowed: true, remaining: RATE_LIMIT_REQUESTS };
    }

    const requestCount = recentRequests?.length || 0;
    const remaining = Math.max(0, RATE_LIMIT_REQUESTS - requestCount);
    
    return {
      allowed: requestCount < RATE_LIMIT_REQUESTS,
      remaining
    };
  } catch (error) {
    console.error('Rate limit error:', error);
    return { allowed: true, remaining: RATE_LIMIT_REQUESTS };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Parse and validate request body
    let body: unknown;
    try {
      body = await req.json();
    } catch {
      return new Response(
        JSON.stringify({ error: 'Invalid JSON in request body' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Validate request with Zod
    const validationResult = requestSchema.safeParse(body);
    if (!validationResult.success) {
      console.error('Validation error:', validationResult.error.errors);
      return new Response(
        JSON.stringify({ 
          error: 'Invalid request format', 
          details: validationResult.error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { messages, userContext, conversationId } = validationResult.data;
    
    console.log('Received validated request:', { 
      messageCount: messages.length, 
      hasUserContext: !!userContext, 
      conversationId 
    });

    const LOVABLE_API_KEY = Deno.env.get('LOVABLE_API_KEY');
    if (!LOVABLE_API_KEY) {
      throw new Error('LOVABLE_API_KEY is not set');
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Generate session ID for rate limiting (use conversationId, userContext.userId, or IP)
    const clientIP = req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 
                     req.headers.get('x-real-ip') || 
                     'unknown';
    const sessionId = userContext?.userId || conversationId || `ip_${clientIP}`;

    // Check rate limit
    const rateLimitResult = await checkRateLimit(supabase, sessionId);
    if (!rateLimitResult.allowed) {
      console.warn('Rate limit exceeded for session:', sessionId);
      return new Response(
        JSON.stringify({ 
          error: 'Limite de requisiÃ§Ãµes excedido. Tente novamente em 1 hora.',
          retryAfter: 3600
        }),
        { 
          status: 429, 
          headers: { 
            ...corsHeaders, 
            'Content-Type': 'application/json',
            'Retry-After': '3600'
          } 
        }
      );
    }

    // Verificar se IA estÃ¡ desabilitada para esta conversa
    if (conversationId) {
      const { data: conversation } = await supabase
        .from('chat_conversations')
        .select('ai_enabled, assigned_to')
        .eq('id', conversationId)
        .single();

      if (conversation && conversation.ai_enabled === false) {
        console.log('AI disabled for this conversation, returning error');
        return new Response(
          JSON.stringify({ 
            error: 'Esta conversa estÃ¡ sendo atendida por um humano. Aguarde o atendente.',
            assigned: true 
          }),
          { 
            status: 403,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          }
        );
      }
    }

    // Buscar contexto do banco de dados
    const dbContext = await gatherDatabaseContext(supabase, userContext);
    
    // Extrair a Ãºltima mensagem do usuÃ¡rio para classificaÃ§Ã£o de mÃ³dulos
    const lastUserMessage = messages.filter(m => m.role === 'user').pop()?.content || '';
    
    // Buscar prompt customizado do banco ou usar fallback (com seleÃ§Ã£o inteligente de mÃ³dulos)
    const { prompt: systemPrompt, modulesUsed, classificationMethod } = await getSystemPrompt(
      supabase, 
      userContext, 
      dbContext,
      lastUserMessage,
      LOVABLE_API_KEY
    );
    
    const fullMessages = [
      { role: 'system' as const, content: systemPrompt },
      ...messages
    ];

    console.log('Making Lovable AI request with', fullMessages.length, 'messages');

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${LOVABLE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'openai/gpt-5-mini',
        messages: fullMessages,
        stream: true,
      }),
    });

    if (!response.ok) {
      if (response.status === 429) {
        return new Response(
          JSON.stringify({ error: 'Limite de requisiÃ§Ãµes excedido. Tente novamente em instantes.' }),
          { status: 429, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
      if (response.status === 402) {
        return new Response(
          JSON.stringify({ error: 'CrÃ©ditos insuficientes. Entre em contato com o administrador.' }),
          { status: 402, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
      const errorText = await response.text();
      console.error('Lovable AI API error:', response.status, errorText);
      throw new Error(`Lovable AI API error: ${errorText}`);
    }

    // Registrar uso de IA (sem contagem exata de tokens pois streaming nÃ£o retorna usage)
    const { error: logError } = await supabase.from('ai_usage_logs').insert({
      conversation_id: conversationId || null,
      session_id: sessionId,
      model: 'openai/gpt-5-mini',
      has_knowledge_modules: modulesUsed.length > 0,
      success: true
    });

    console.log(`Modules loaded: ${classificationMethod === 'none' ? 'NONE (GPT knowledge only)' : modulesUsed.length > 0 ? modulesUsed.join(', ') : 'ALL'} (method: ${classificationMethod})`);

    if (logError) {
      console.error('Erro ao registrar uso de IA:', logError);
    }

    // Retornar stream SSE diretamente
    return new Response(response.body, {
      headers: { ...corsHeaders, 'Content-Type': 'text/event-stream' },
    });

  } catch (error) {
    console.error('Error in chat-with-ai function:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    // Registrar erro de uso de IA
    try {
      const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
      const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
      const supabase = createClient(supabaseUrl, supabaseKey);
      
      await supabase.from('ai_usage_logs').insert({
        session_id: null,
        model: 'openai/gpt-5-mini',
        success: false,
        error_message: errorMessage
      });
    } catch (logError) {
      console.error('Erro ao registrar falha de uso de IA:', logError);
    }
    
    return new Response(JSON.stringify({ error: errorMessage }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

// Buscar mÃ³dulos de conhecimento com texto extraÃ­do
async function getKnowledgeModules(supabase: any) {
  try {
    // Buscar mÃ³dulos com arquivos
    const { data: modules, error: modulesError } = await supabase
      .from('knowledge_modules')
      .select(`
        id,
        name,
        variable_name,
        version,
        description
      `)
      .order('display_order');

    if (modulesError) {
      console.error('Error fetching modules:', modulesError);
      return { modules: [], config: {} };
    }

    // Buscar arquivos com texto extraÃ­do para cada mÃ³dulo
    const modulesWithContent = [];
    for (const module of modules || []) {
      const { data: files } = await supabase
        .from('knowledge_module_files')
        .select('file_name, extracted_text')
        .eq('module_id', module.id)
        .order('uploaded_at', { ascending: false });

      modulesWithContent.push({
        ...module,
        files: files || []
      });
    }

    // Buscar configuraÃ§Ã£o global
    const { data: configData } = await supabase
      .from('knowledge_config')
      .select('key, value');

    const config: Record<string, string> = {};
    (configData || []).forEach((item: any) => {
      config[item.key] = item.value;
    });

  return { modules: modulesWithContent, config };
  } catch (error) {
    console.error('Error in getKnowledgeModules:', error);
    return { modules: [], config: {} };
  }
}

// Mapeamento de palavras-chave para mÃ³dulos
const MODULE_KEYWORDS: Record<string, string[]> = {
  'MODULO_CRM_SALES': [
    'crm', 'sales', 'lead', 'leads', 'oportunidade', 'oportunidades', 'pipeline',
    'funil', 'vendas', 'conversÃ£o', 'prospecÃ§Ã£o', 'cliente', 'clientes',
    'atendimento', 'captaÃ§Ã£o', 'cadastro cliente', 'cadastrar cliente'
  ],
  'MODULO_NET_LOCACAO': [
    'locaÃ§Ã£o', 'locacao', 'aluguel', 'alugar', 'inquilino', 'locatÃ¡rio', 'locatario',
    'contrato locaÃ§Ã£o', 'contrato aluguel', 'fiador', 'caucao', 'cauÃ§Ã£o',
    'vistoria', 'rescisÃ£o', 'renovaÃ§Ã£o', 'reajuste', 'despejo', 'garantia locatÃ­cia'
  ],
  'MODULO_AREA_DO_CLIENTE': [
    'Ã¡rea do cliente', 'area do cliente', 'portal cliente', 'acesso cliente',
    'segunda via', 'boleto', 'extrato', 'informe', 'declaraÃ§Ã£o', 'ir',
    'imposto de renda', 'autoatendimento', 'meu espaÃ§o'
  ],
  'MODULO_NET_VENDAS': [
    'venda imÃ³vel', 'venda imovel', 'compra', 'comprar', 'financiamento',
    'proposta compra', 'opÃ§Ã£o', 'opcao', 'angariaÃ§Ã£o', 'angariacao',
    'captaÃ§Ã£o imÃ³vel', 'captacao imovel', 'exclusividade', 'avaliaÃ§Ã£o',
    'documentaÃ§Ã£o venda', 'escritura', 'certidÃ£o', 'matrÃ­cula'
  ],
  'MODULO_TRANSVERSAL': [
    'login', 'senha', 'acesso', 'permissÃ£o', 'permissao', 'usuÃ¡rio', 'usuario',
    'perfil', 'configuraÃ§Ã£o', 'configuracao', 'geral', 'sistema', 'erro',
    'problema', 'bug', 'nÃ£o funciona', 'ajuda', 'tutorial'
  ]
};

// Classificar mÃ³dulos relevantes por palavras-chave
function classifyModulesByKeywords(userMessage: string): string[] {
  const messageLower = userMessage.toLowerCase();
  const relevantModules: Set<string> = new Set();
  
  for (const [moduleName, keywords] of Object.entries(MODULE_KEYWORDS)) {
    for (const keyword of keywords) {
      if (messageLower.includes(keyword)) {
        relevantModules.add(moduleName);
        break;
      }
    }
  }
  
  // Sempre incluir MODULO_TRANSVERSAL como fallback
  relevantModules.add('MODULO_TRANSVERSAL');
  
  // Se nÃ£o encontrou nada especÃ­fico alÃ©m do transversal, carregar todos
  if (relevantModules.size === 1) {
    return []; // Retorna vazio para indicar "carregar todos"
  }
  
  return Array.from(relevantModules);
}

// Classificar mÃ³dulos usando IA (fallback para casos complexos)
async function classifyModulesWithAI(
  userMessage: string, 
  availableModules: { name: string, variable_name: string }[],
  apiKey: string
): Promise<string[]> {
  try {
    const moduleList = availableModules.map(m => `- ${m.variable_name}: ${m.name}`).join('\n');
    
    const classificationPrompt = `Analise a pergunta do usuÃ¡rio e retorne APENAS os nomes das variÃ¡veis dos mÃ³dulos relevantes, separados por vÃ­rgula.

MÃ³dulos disponÃ­veis:
${moduleList}

Pergunta do usuÃ¡rio: "${userMessage}"

Regras:
- Retorne APENAS os variable_names separados por vÃ­rgula, sem explicaÃ§Ã£o
- Sempre inclua MODULO_TRANSVERSAL
- Se a pergunta for muito genÃ©rica, retorne: TODOS

Resposta (apenas os nomes):`;

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'openai/gpt-5-mini',
        messages: [{ role: 'user', content: classificationPrompt }],
        max_tokens: 100
      }),
    });

    if (!response.ok) {
      console.error('AI classification failed, loading all modules');
      return [];
    }

    const data = await response.json();
    const result = data.choices[0].message.content.trim();
    
    if (result.toUpperCase().includes('TODOS')) {
      return [];
    }
    
    const moduleNames = result.split(',').map((m: string) => m.trim().toUpperCase());
    
    // Validar que os mÃ³dulos retornados existem
    const validModules = moduleNames.filter((name: string) => 
      availableModules.some(m => m.variable_name.toUpperCase() === name)
    );
    
    // Garantir que MODULO_TRANSVERSAL estÃ¡ incluÃ­do
    if (!validModules.includes('MODULO_TRANSVERSAL')) {
      validModules.push('MODULO_TRANSVERSAL');
    }
    
    return validModules.length > 0 ? validModules : [];
  } catch (error) {
    console.error('Error in AI classification:', error);
    return [];
  }
}

// FunÃ§Ã£o principal de classificaÃ§Ã£o (hÃ­brida)
async function classifyRelevantModules(
  userMessage: string,
  availableModules: { name: string, variable_name: string }[],
  apiKey: string
): Promise<{ modules: string[], method: 'keywords' | 'ai' | 'all' | 'none' }> {
  // Primeiro: tentar classificaÃ§Ã£o por palavras-chave (custo zero)
  const keywordModules = classifyModulesByKeywords(userMessage);
  
  if (keywordModules.length > 0) {
    console.log(`Module classification by keywords: ${keywordModules.join(', ')}`);
    return { modules: keywordModules, method: 'keywords' };
  }
  
  // Se palavras-chave nÃ£o funcionaram, usar IA para classificar
  console.log('Keywords inconclusive, trying AI classification...');
  const aiModules = await classifyModulesWithAI(userMessage, availableModules, apiKey);
  
  if (aiModules.length > 0) {
    console.log(`Module classification by AI: ${aiModules.join(', ')}`);
    return { modules: aiModules, method: 'ai' };
  }
  
  // Fallback: nÃ£o carregar nenhum mÃ³dulo, GPT responde com conhecimento prÃ³prio
  console.log('No modules matched - GPT will use its own knowledge (fallback none)');
  return { modules: [], method: 'none' };
}

// Gerar Ã­ndice de mÃ³dulos
function buildModuleIndex(modules: any[]): string {
  if (!modules.length) return '[Nenhum mÃ³dulo de conhecimento configurado]';

  let index = 'ğŸ“š **ÃNDICE DE MÃ“DULOS DE CONHECIMENTO**\n\n';
  index += '| # | MÃ³dulo | VariÃ¡vel | VersÃ£o | Documentos |\n';
  index += '|---|--------|----------|--------|------------|\n';

  for (let i = 0; i < modules.length; i++) {
    const mod = modules[i];
    const fileCount = mod.files?.length || 0;
    const hasContent = mod.files?.some((f: any) => f.extracted_text) || false;
    const status = hasContent ? 'âœ…' : (fileCount > 0 ? 'â³' : 'âŒ');
    index += `| ${i + 1} | ${mod.name} | {{${mod.variable_name}}} | v${mod.version || '1.0'} | ${fileCount} ${status} |\n`;
  }

  return index;
}

// Gerar conteÃºdo de um mÃ³dulo
function buildModuleContent(module: any): string {
  if (!module.files?.length) {
    return `[MÃ³dulo ${module.name}: Nenhum documento disponÃ­vel]`;
  }

  const filesWithText = module.files.filter((f: any) => f.extracted_text);
  
  if (!filesWithText.length) {
    return `[MÃ³dulo ${module.name}: Documentos em processamento - ${module.files.length} arquivo(s)]`;
  }

  let content = `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
  content += `ğŸ“˜ ${module.name.toUpperCase()} - VERSÃƒO ${module.version || '1.0'}\n`;
  content += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;

  for (const file of filesWithText) {
    content += `--- ${file.file_name} ---\n\n`;
    content += file.extracted_text + '\n\n';
  }

  return content;
}

async function getSystemPrompt(
  supabase: any, 
  userContext?: UserContext, 
  dbContext?: string,
  userMessage?: string,
  apiKey?: string
): Promise<{ prompt: string, modulesUsed: string[], classificationMethod: 'keywords' | 'ai' | 'all' | 'none' }> {
  try {
    // Buscar prompt customizado do banco
    const { data: promptData, error } = await supabase
      .from('system_prompts')
      .select('content')
      .eq('name', 'master_prompt_aia')
      .eq('is_active', true)
      .single();

    if (error || !promptData?.content) {
      console.log('No custom prompt found, using fallback');
      return { 
        prompt: buildSystemPrompt(userContext, dbContext), 
        modulesUsed: [], 
        classificationMethod: 'all' 
      };
    }

    console.log('Using custom prompt from database');
    
    // Substituir variÃ¡veis dinÃ¢micas
    let customPrompt = promptData.content;
    
    // Buscar mÃ³dulos de conhecimento
    const { modules, config } = await getKnowledgeModules(supabase);
    console.log(`Found ${modules.length} knowledge modules`);
    
    // Classificar quais mÃ³dulos sÃ£o relevantes para a pergunta do usuÃ¡rio
    let modulesUsed: string[] = [];
    let classificationMethod: 'keywords' | 'ai' | 'all' | 'none' = 'all';
    
    if (userMessage && apiKey && modules.length > 0) {
      const classification = await classifyRelevantModules(
        userMessage,
        modules.map(m => ({ name: m.name, variable_name: m.variable_name })),
        apiKey
      );
      modulesUsed = classification.modules;
      classificationMethod = classification.method;
    }
    
    const loadAllModules = modulesUsed.length === 0 && classificationMethod !== 'none';
    const loadNoModules = classificationMethod === 'none';
    
    // Substituir {{VERSAO_MODULOS}}
    const globalVersion = config['VERSAO_MODULOS'] || '1.0';
    customPrompt = customPrompt.replace(/\{\{VERSAO_MODULOS\}\}/g, globalVersion);
    
    // Substituir {{INDICE_DE_MODULOS}}
    const moduleIndex = buildModuleIndex(modules);
    customPrompt = customPrompt.replace(/\{\{INDICE_DE_MODULOS\}\}/g, moduleIndex);
    
    // Substituir variÃ¡veis de cada mÃ³dulo (carrega apenas os relevantes)
    let loadedModulesCount = 0;
    for (const module of modules) {
      const regex = new RegExp(`\\{\\{${module.variable_name}\\}\\}`, 'g');
      
      const shouldLoad = !loadNoModules && (loadAllModules || modulesUsed.some(
        m => m.toUpperCase() === module.variable_name.toUpperCase()
      ));
      
      if (shouldLoad) {
        // Carrega o conteÃºdo completo do mÃ³dulo
        const moduleContent = buildModuleContent(module);
        customPrompt = customPrompt.replace(regex, moduleContent);
        loadedModulesCount++;
      } else {
        // Substitui por placeholder indicando que o mÃ³dulo existe mas nÃ£o foi carregado
        customPrompt = customPrompt.replace(regex, 
          `[ğŸ“ MÃ³dulo "${module.name}" disponÃ­vel - nÃ£o carregado para esta consulta. Se precisar de informaÃ§Ãµes deste mÃ³dulo, pergunte especificamente sobre ${module.name.toLowerCase()}.]\n`
        );
      }
    }
    
    console.log(`Loaded ${loadedModulesCount} of ${modules.length} modules (${loadNoModules ? 'none - GPT knowledge only' : loadAllModules ? 'all' : 'selective'})`);
    
    // Substituir {{database_context}}
    if (dbContext) {
      customPrompt = customPrompt.replace(/\{\{database_context\}\}/g, dbContext);
    } else {
      customPrompt = customPrompt.replace(/\{\{database_context\}\}/g, '');
    }
    
    // Substituir {{user_context}}
    if (userContext) {
      let userContextStr = '';
      if (userContext.userId) userContextStr += `- ID do usuÃ¡rio: ${userContext.userId}\n`;
      if (userContext.currentSystem) userContextStr += `- Sistema atual: ${userContext.currentSystem}\n`;
      if (userContext.permissions?.length) userContextStr += `- PermissÃµes: ${userContext.permissions.join(', ')}\n`;
      if (userContext.lastAction) userContextStr += `- Ãšltima aÃ§Ã£o: ${userContext.lastAction}\n`;
      customPrompt = customPrompt.replace(/\{\{user_context\}\}/g, userContextStr || 'Contexto nÃ£o disponÃ­vel');
    } else {
      customPrompt = customPrompt.replace(/\{\{user_context\}\}/g, '');
    }
    
    // Substituir {{user_name}}
    if (userContext?.userId) {
      const { data: profile } = await supabase
        .from('profiles')
        .select('display_name')
        .eq('user_id', userContext.userId)
        .single();
      
      customPrompt = customPrompt.replace(/\{\{user_name\}\}/g, profile?.display_name || 'UsuÃ¡rio');
    } else {
      customPrompt = customPrompt.replace(/\{\{user_name\}\}/g, 'UsuÃ¡rio');
    }
    
    return { 
      prompt: customPrompt, 
      modulesUsed: loadNoModules ? [] : loadAllModules ? modules.map(m => m.variable_name) : modulesUsed,
      classificationMethod 
    };
  } catch (error) {
    console.error('Error fetching custom prompt:', error);
    return { 
      prompt: buildSystemPrompt(userContext, dbContext), 
      modulesUsed: [], 
      classificationMethod: 'all' 
    };
  }
}

async function gatherDatabaseContext(supabase: any, userContext?: UserContext) {
  let context = '';

  try {
    // Buscar estatÃ­sticas gerais do sistema
    const { data: conversationsData } = await supabase
      .from('chat_conversations')
      .select('category, sentiment, tags')
      .limit(50);

    if (conversationsData?.length) {
      const categories = [...new Set(conversationsData.map((c: any) => c.category))];
      const sentiments = [...new Set(conversationsData.map((c: any) => c.sentiment))];
      
      context += `\nEstatÃ­sticas do sistema:\n`;
      context += `- Categorias frequentes: ${categories.join(', ')}\n`;
      context += `- Sentimentos dos usuÃ¡rios: ${sentiments.join(', ')}\n`;
      context += `- Total de conversas recentes: ${conversationsData.length}\n`;
    }

    // Buscar perfis de usuÃ¡rios para entender o contexto
    const { data: profilesData } = await supabase
      .from('profiles')
      .select('display_name, email')
      .limit(10);

    if (profilesData?.length) {
      context += `\nUsuÃ¡rios ativos no sistema: ${profilesData.length} perfis cadastrados\n`;
    }

    // Se temos contexto do usuÃ¡rio especÃ­fico
    if (userContext?.userId) {
      const { data: userProfile } = await supabase
        .from('profiles')
        .select('display_name, email')
        .eq('user_id', userContext.userId)
        .single();

      if (userProfile) {
        context += `\nPerfil do usuÃ¡rio atual:\n`;
        context += `- Nome: ${userProfile.display_name || 'NÃ£o informado'}\n`;
        context += `- Email: ${userProfile.email || 'NÃ£o informado'}\n`;
      }

      // Buscar conversas anteriores do usuÃ¡rio
      const { data: userConversations } = await supabase
        .from('chat_conversations')
        .select('category, sentiment, tags, total_messages')
        .eq('session_id', userContext.userId)
        .order('started_at', { ascending: false })
        .limit(5);

      if (userConversations?.length) {
        context += `\nHistÃ³rico do usuÃ¡rio:\n`;
        context += `- Conversas anteriores: ${userConversations.length}\n`;
        context += `- Categorias principais: ${[...new Set(userConversations.map((c: any) => c.category))].join(', ')}\n`;
      }
    }

  } catch (error) {
    console.error('Error gathering database context:', error);
    context += '\nNÃ£o foi possÃ­vel acessar dados contextuais do sistema.';
  }

  return context;
}

function buildSystemPrompt(userContext?: UserContext, dbContext?: string): string {
  const basePrompt = `ğŸ¯ IDENTIDADE E PROPÃ“SITO

VocÃª Ã© um assistente especializado em suporte tÃ©cnico para os sistemas e procedimentos da empresa Apolar ImÃ³veis:
- Sistemas: Apolar Sales (CRM) e Apolar NET (ERP)

Seu objetivo principal Ã©:
âœ… Ajudar usuÃ¡rios a utilizar os sistemas de forma eficiente
âœ… Oferecer respostas claras, passo a passo, e com empatia
âœ… Reduzir abertura de tickets desnecessÃ¡rios
âœ… Orientar sobre funcionalidades dos sistemas
âœ… Consultar e informar status de tickets existentes
âœ… Orientar sobre procedimentos que vocÃª conhece por meio dos manuais

ğŸ‘¥ PÃšBLICO-ALVO
- UsuÃ¡rios internos da empresa
- NÃ­veis de conhecimento tÃ©cnico variados
- Pessoas que precisam de respostas rÃ¡pidas e precisas

ğŸ“‹ TOM E ESTRUTURA
Tom: Profissional, amigÃ¡vel, claro, empÃ¡tico e paciente

Estrutura das respostas:
1. SaudaÃ§Ã£o (apenas no primeiro contato)
2. ConfirmaÃ§Ã£o do problema (reformule para validar entendimento)
3. SoluÃ§Ã£o passo a passo (numerada quando necessÃ¡rio)
4. Pergunta de follow-up (confirmar se resolveu ou se precisa de mais ajuda)

ğŸš§ LIMITAÃ‡Ã•ES E ESCALAÃ‡ÃƒO

NÃƒO resolver:
âŒ Problemas que requerem acesso administrativo
âŒ AlteraÃ§Ãµes crÃ­ticas de configuraÃ§Ã£o
âŒ Bugs que necessitam de desenvolvimento
âŒ SolicitaÃ§Ãµes fora do escopo (nÃ£o relacionadas ao CRM/ERP)

Como escalar:
"Identifiquei que seu caso precisa de atenÃ§Ã£o especializada. Por gentileza, siga com a abertura de um ticket por meio da plataforma Movidesk (https://apolarimoveis.movidesk.com/Account/Login), com a seguinte descriÃ§Ã£o: [resumo detalhado do problema]"

ğŸ“š MANUAIS E PROCEDIMENTOS

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“˜ MANUAL APOLAR SALES (CRM) - VERSÃƒO 01
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” 1. ACESSO INICIAL

Para acessar o sistema Apolar Sales:

**Passo 1: Acesso pelo Apolar NET**
1. Entre no Apolar NET (sistema ERP)
2. No menu lateral, localize e clique em "Apolar Sales"
3. VocÃª serÃ¡ redirecionado automaticamente

**Passo 2: Primeiro acesso**
1. Insira seu e-mail corporativo
2. Clique em "Esqueci minha senha"
3. VocÃª receberÃ¡ um e-mail com link para criar sua senha
4. Defina uma senha forte (mÃ­nimo 8 caracteres)
5. FaÃ§a login com suas credenciais

ğŸ‘¤ 2. TIPOS DE ACESSO

O sistema possui 4 nÃ­veis de acesso:

**ADMINISTRADOR**
- Acesso total ao sistema
- Gerenciamento de usuÃ¡rios e permissÃµes
- ConfiguraÃ§Ãµes globais
- RelatÃ³rios completos

**GERENTE**
- VisualizaÃ§Ã£o de toda a equipe
- GestÃ£o de leads e oportunidades da Ã¡rea
- RelatÃ³rios gerenciais
- AprovaÃ§Ãµes de processos

**CORRETOR**
- GestÃ£o de seus prÃ³prios leads
- Registro de atendimentos
- Acompanhamento de propostas
- Acesso a informaÃ§Ãµes de imÃ³veis

**VISUALIZADOR**
- Apenas consulta
- Sem permissÃ£o de ediÃ§Ã£o
- Acesso limitado a relatÃ³rios

ğŸ”„ 3. FUNCIONALIDADES PRINCIPAIS

**Dashboard**
- VisÃ£o geral de atividades
- MÃ©tricas de desempenho
- Tarefas pendentes
- Alertas importantes

**Leads**
- Cadastro de novos leads
- QualificaÃ§Ã£o e classificaÃ§Ã£o
- HistÃ³rico de interaÃ§Ãµes
- DistribuiÃ§Ã£o automÃ¡tica

**Oportunidades**
- Pipeline de vendas
- Acompanhamento de propostas
- PrevisÃ£o de fechamento
- RelatÃ³rios de conversÃ£o

**ImÃ³veis**
- Consulta de disponibilidade
- CaracterÃ­sticas e fotos
- Valores e condiÃ§Ãµes
- LocalizaÃ§Ã£o e entorno

â“ 4. PROBLEMAS FREQUENTES

**Problema: NÃ£o consigo fazer login**
SoluÃ§Ã£o:
1. Verifique se estÃ¡ usando o e-mail corporativo correto
2. Tente recuperar a senha clicando em "Esqueci minha senha"
3. Limpe o cache do navegador
4. Tente em outro navegador

**Problema: Lead duplicado**
SoluÃ§Ã£o:
1. Use a funÃ§Ã£o de busca antes de cadastrar
2. Verifique pelo CPF, telefone ou e-mail
3. Se encontrar duplicata, solicite a mesclagem ao gestor

**Problema: RelatÃ³rio nÃ£o carrega**
SoluÃ§Ã£o:
1. Aguarde alguns segundos
2. Reduza o perÃ­odo do relatÃ³rio
3. Limpe o cache do navegador
4. Se persistir, abra ticket no suporte

ğŸ“ CANAIS DE SUPORTE

- **Chatbot AIA**: Para dÃºvidas rÃ¡pidas e procedimentos
- **Movidesk**: Para tickets tÃ©cnicos e problemas complexos (https://apolarimoveis.movidesk.com/Account/Login)
- **Gestor direto**: Para questÃµes de permissÃµes e acessos`;

  let fullPrompt = basePrompt;

  if (dbContext) {
    fullPrompt += `\n\nğŸ“Š CONTEXTO ATUAL DO SISTEMA\n${dbContext}`;
  }

  if (userContext) {
    fullPrompt += `\n\nğŸ‘¤ INFORMAÃ‡Ã•ES DO USUÃRIO ATUAL`;
    if (userContext.userId) fullPrompt += `\n- ID: ${userContext.userId}`;
    if (userContext.currentSystem) fullPrompt += `\n- Sistema: ${userContext.currentSystem}`;
    if (userContext.permissions?.length) fullPrompt += `\n- PermissÃµes: ${userContext.permissions.join(', ')}`;
    if (userContext.lastAction) fullPrompt += `\n- Ãšltima aÃ§Ã£o: ${userContext.lastAction}`;
  }

  return fullPrompt;
}

async function saveMessages(supabase: any, conversationId: string, userMessage: string, aiResponse: string) {
  try {
    // Buscar o Ãºltimo message_order da conversa
    const { data: lastMessage, error: fetchError } = await supabase
      .from('chat_messages')
      .select('message_order')
      .eq('conversation_id', conversationId)
      .order('message_order', { ascending: false })
      .limit(1)
      .single();

    let nextOrder = 1;
    if (!fetchError && lastMessage) {
      nextOrder = (lastMessage.message_order || 0) + 1;
    }

    // Inserir mensagem do usuÃ¡rio
    const { error: userMsgError } = await supabase
      .from('chat_messages')
      .insert({
        conversation_id: conversationId,
        content: userMessage,
        is_user: true,
        message_order: nextOrder
      });

    if (userMsgError) {
      console.error('Error saving user message:', userMsgError);
    }

    // Inserir resposta da IA
    const { error: aiMsgError } = await supabase
      .from('chat_messages')
      .insert({
        conversation_id: conversationId,
        content: aiResponse,
        is_user: false,
        message_order: nextOrder + 1
      });

    if (aiMsgError) {
      console.error('Error saving AI message:', aiMsgError);
    }

    // Atualizar contador de mensagens na conversa
    await supabase
      .from('chat_conversations')
      .update({ total_messages: nextOrder + 1 })
      .eq('id', conversationId);

  } catch (error) {
    console.error('Error in saveMessages:', error);
  }
}
